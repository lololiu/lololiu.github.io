<html>
<head><meta name="generator" content="Hexo 3.8.0">
	
	<title>zxing开源库工作流程源码详解</title>
	<meta name="keywords" content="My Blog, Spider Bitch!">
    <meta name="baidu-site-verification" content="vxDbv63a4S">
    <meta name="google-site-verification" content="9eUnNRo8qiEexz_FacVB-p-0z9OViF--gZ9kfL5hofo">
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no">

    
    <!--<link rel="stylesheet" href="/css/main.css">-->
    <link rel="stylesheet" href="/css/bootstrap.min.css">
    <link rel="stylesheet" href="/css/bootstrap-theme.min.css">
    <link href="/css/main.css?v=2" rel="stylesheet" type="text/css">
    <script src="/js/jquery.min.js"></script>
    <script src="/js/common.js"></script>
    <!--<link rel="stylesheet" href="/css/style.css">-->
    

    <link rel="alternate" type="application/atom+xml" href="/atom.xml" title="Atom feed">

    
	<link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2">
    

</head>

<body 
	
	>



    <div class="container center-block">
        <div class="col-md-1"></div>
        <div class="col-md-10 col-sm-12">
            <h2 id="zxing开源库工作流程源码详解"><a href="#zxing开源库工作流程源码详解" class="headerlink" title="zxing开源库工作流程源码详解"></a>zxing开源库工作流程源码详解</h2><h3 id="代码获取"><a href="#代码获取" class="headerlink" title="代码获取"></a>代码获取</h3><p>作为移动客户端开发者来说，对二维码识别或二维码生成相关的开发需求肯定并不陌生，Android开发二维码相关的功能通常都会使用或参考大名鼎鼎的<a href="https://github.com/zxing/zxing" target="_blank" rel="noopener">zxing</a>库。而本文则主要是通过源码分析一下该开源库扫描二维码的工作流程，对这块能有个更深的了解。</p>
<p>首先使用git将项目代码clone到本地，新建项目，将zxing文件夹中的<code>android</code>以及<code>core</code>文件夹代码覆盖到对应的目录下，稍作一些修改即可运行一个简单的二维码扫描的示例应用。</p>
<h3 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h3><p>Demo代码运行起来后，会进入一个扫描的主功能界面，将扫描框对准一个二维码即可弹出解析结果信息的浮框。通过<code>AndroidManifest.xml</code>文件中可以得知这个页面对应的类为<code>CaptureActivity.java</code>，我们便从这个类开始，分析整个二维码扫描的流程。</p>
<p>要分析一个Activity，当然要从它的生命周期所对应的各个方法说起。首先我们来看它的<code>onCreate()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle icicle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(icicle);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保持屏幕常亮</span></span><br><span class="line">    Window window = getWindow();</span><br><span class="line">    window.addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);</span><br><span class="line">    setContentView(R.layout.capture);</span><br><span class="line"></span><br><span class="line">    hasSurface = <span class="keyword">false</span>;</span><br><span class="line">    inactivityTimer = <span class="keyword">new</span> InactivityTimer(<span class="keyword">this</span>);</span><br><span class="line">    beepManager = <span class="keyword">new</span> BeepManager(<span class="keyword">this</span>);</span><br><span class="line">    ambientLightManager = <span class="keyword">new</span> AmbientLightManager(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    PreferenceManager.setDefaultValues(<span class="keyword">this</span>, R.xml.preferences, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法代码不多，也很容易看懂，主要就是做一些初始化的工作。<code>InactivityTimer</code>主要是用来监听当手机是使用电池而不是充电状态时，如果5分钟内没有做任何操作，则主动finish掉activity。<code>BeepManager</code>负责扫描到结果后震动或铃声相关，<code>AmbientLightManager</code>则是负责控制闪光灯。</p>
<p>继续往下走看<code>onResume()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onResume();</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CameraManager must be initialized here, not in onCreate(). This is necessary because we don't</span></span><br><span class="line">	<span class="comment">// want to open the camera driver and measure the screen size if we're going to show the help on</span></span><br><span class="line">	<span class="comment">// first launch. That led to bugs where the scanning rectangle was the wrong size and partially</span></span><br><span class="line">	<span class="comment">// off screen.</span></span><br><span class="line">	cameraManager = <span class="keyword">new</span> CameraManager(getApplication());</span><br><span class="line"></span><br><span class="line">    viewfinderView = (ViewfinderView) findViewById(R.id.viewfinder_view);</span><br><span class="line">    viewfinderView.setCameraManager(cameraManager);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    SurfaceView surfaceView = (SurfaceView) findViewById(R.id.preview_view);</span><br><span class="line">    SurfaceHolder surfaceHolder = surfaceView.getHolder();</span><br><span class="line">    <span class="keyword">if</span> (hasSurface) &#123;</span><br><span class="line">        <span class="comment">// The activity was paused but not stopped, so the surface still exists. Therefore</span></span><br><span class="line">        <span class="comment">// surfaceCreated() won't be called, so init the camera here.</span></span><br><span class="line">        initCamera(surfaceHolder);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Install the callback and wait for surfaceCreated() to init the camera.</span></span><br><span class="line">        surfaceHolder.addCallback(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法很重要，初始化了<code>CameraManager</code>，扫描二维码毋庸置疑是需要用到相机，通过相机预览的一帧一帧的图片，去解析上面可能存在的二维码信息。而在最后面还初始化了<code>SurfaceView</code>，通过<code>hasSurface</code>来决定是走<code>initCamera(surfaceHolder)</code>还是<code>surfaceHolder.addCallback(this)</code>。在上面的<code>onCreate()</code>中我们可以看到<code>hasSurface</code>被初始化成<code>false</code>，所以这里走的应该是<code>else</code>的代码块。<code>CaptureActivity</code>实现了<code>SurfaceHolder.Callback</code>接口，因此该方法绑定了<code>surfaceHolder</code>的回调。当<code>SurfaceView</code>添加到 activity 中时，会调用<code>surfaceCreated()</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">surfaceCreated</span><span class="params">(SurfaceHolder holder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (holder == <span class="keyword">null</span>) &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">"*** WARNING *** surfaceCreated() gave us a null surface!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!hasSurface) &#123;</span><br><span class="line">        hasSurface = <span class="keyword">true</span>;</span><br><span class="line">        initCamera(holder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们看到会改变<code>hasSurface</code>的状态，然后走<code>initCamera(holder)</code>，和<code>onResume()</code>中 <code>hasSurface</code>为<code>true</code>时做的操作是一样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cameraManager.openDriver(surfaceHolder);</span><br><span class="line"><span class="comment">// Creating the handler starts the preview, which can also throw a RuntimeException.</span></span><br><span class="line"><span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">    handler = <span class="keyword">new</span> CaptureActivityHandler(<span class="keyword">this</span>, decodeFormats, decodeHints, characterSet, cameraManager);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>cameraManager</code> 打开了驱动，并且把自己传入一个<code>CaptureActivityHandler</code>对象中去，那这个<code>CaptureActivityHandler</code>看起来像是一个进行消息通知的 Handler，它的具体作用又是什么呢？我们来看看它的构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CaptureActivityHandler(CaptureActivity activity,</span><br><span class="line">                       Collection&lt;BarcodeFormat&gt; decodeFormats,</span><br><span class="line">                       Map&lt;DecodeHintType,?&gt; baseHints,</span><br><span class="line">                       String characterSet,</span><br><span class="line">                       CameraManager cameraManager) &#123;</span><br><span class="line">    <span class="keyword">this</span>.activity = activity;</span><br><span class="line">    decodeThread = <span class="keyword">new</span> DecodeThread(activity, decodeFormats, baseHints, characterSet,<span class="keyword">new</span> ViewfinderResultPointCallback(activity.getViewfinderView()));</span><br><span class="line">    decodeThread.start();</span><br><span class="line">    state = State.SUCCESS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start ourselves capturing previews and decoding.</span></span><br><span class="line">    <span class="keyword">this</span>.cameraManager = cameraManager;</span><br><span class="line">    cameraManager.startPreview();</span><br><span class="line">    restartPreviewAndDecode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过进入<code>CaptureActivityHandler.java</code>可以看到该类确实继承了<code>Handler</code>，并且在它的构造方法中开启了一个<code>DecodeThread</code>的线程，并且调用了<code>cameraManager</code>的<code>startPreview()</code>方法：</p>
<blockquote>
<p>Asks the camera hardware to begin drawing preview frames to the screen.</p>
</blockquote>
<p>开启相机预览后，再看下面的<code>restartPreviewAndDecode()</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">restartPreviewAndDecode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (state == State.SUCCESS) &#123;</span><br><span class="line">        state = State.PREVIEW;</span><br><span class="line">        cameraManager.requestPreviewFrame(decodeThread.getHandler(), R.id.decode);</span><br><span class="line">        activity.drawViewfinder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">requestPreviewFrame</span><span class="params">(Handler handler, <span class="keyword">int</span> message)</span> </span>&#123;</span><br><span class="line">    OpenCamera theCamera = camera;</span><br><span class="line">    <span class="keyword">if</span> (theCamera != <span class="keyword">null</span> &amp;&amp; previewing) &#123;</span><br><span class="line">        previewCallback.setHandler(handler, message);</span><br><span class="line">        theCamera.getCamera().setOneShotPreviewCallback(previewCallback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这个 handler 会一直传递到一个<code>previewCallback</code>对象中去，而<code>PreviewCallback</code>是<code>setOneShotPreviewCallback()</code>方法的一个回调，<code>setOneShotPreviewCallback</code>方法上的注释说明：</p>
<blockquote>
<p>Installs a callback to be invoked for the next preview frame in addition to displaying it on the screen. After one invocation, the callback is cleared. This method can be called any time, even when preview is live.  Any other preview callbacks are overridden.</p>
</blockquote>
<p>使用此方法注册预览回调接口时，会将下一帧数据回调给<code>onPreviewFrame()</code>方法，调用完成后这个回调接口将被销毁，也就是只会回调一次预览帧数据。继续顺着这个方法走下去，看回调方法<code>onPreviewFrame()</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPreviewFrame</span><span class="params">(<span class="keyword">byte</span>[] data, Camera camera)</span> </span>&#123;</span><br><span class="line">    Point cameraResolution = configManager.getCameraResolution();</span><br><span class="line">    Handler thePreviewHandler = previewHandler;</span><br><span class="line">    <span class="keyword">if</span> (cameraResolution != <span class="keyword">null</span> &amp;&amp; thePreviewHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Message message = thePreviewHandler.obtainMessage(previewMessage, cameraResolution.x,cameraResolution.y, data);</span><br><span class="line">        message.sendToTarget();</span><br><span class="line">        previewHandler = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"Got preview callback, but no handler or resolution available"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里将返回的 byte 数组数据和预览帧的宽高信息通过 handler 进行通知，这个 handler 就是上文中传过来的<code>decodeThread.getHandler()</code>，<code>previewMessage</code>为<code>R.id.decode</code>，目的就是把图片数据拿到该线程中进行解析。我们跟进到<code>DecodeHandler.java</code>中查看<code>handleMessage()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (message == <span class="keyword">null</span> || !running) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> (message.what) &#123;</span><br><span class="line">        <span class="keyword">case</span> R.id.decode:</span><br><span class="line">            decode((<span class="keyword">byte</span>[]) message.obj, message.arg1, message.arg2);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> R.id.quit:</span><br><span class="line">            running = <span class="keyword">false</span>;</span><br><span class="line">            Looper.myLooper().quit();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(<span class="keyword">byte</span>[] data, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//省略具体解析代码</span></span><br><span class="line">    ...</span><br><span class="line">    Handler handler = activity.getHandler();<span class="comment">//CaptureActivityHandler</span></span><br><span class="line">    <span class="keyword">if</span> (rawResult != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Don't log the barcode contents for security.</span></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        Log.d(TAG, <span class="string">"Found barcode in "</span> + (end - start) + <span class="string">" ms"</span>);</span><br><span class="line">        <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Message message = Message.obtain(handler, R.id.decode_succeeded, rawResult);</span><br><span class="line">            Bundle bundle = <span class="keyword">new</span> Bundle();</span><br><span class="line">            bundleThumbnail(source, bundle);        </span><br><span class="line">            message.setData(bundle);</span><br><span class="line">            message.sendToTarget();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Message message = Message.obtain(handler, R.id.decode_failed);</span><br><span class="line">            message.sendToTarget();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码很清晰，<code>DecodeHandler</code> 接收到<code>R.id.decode</code>的消息后，会调用<code>decode()</code>方法去解析传过来的图片数据。经过一系列解析操作，得到结果。如果结果为不为空，则通过<code>CaptureActivityHandler</code>将解析成功的消息传到<code>CaptureActivity</code>中进行后续解析结果展示。而如果解析结果为空呢，说明二维码信息解析失败了，传了一个<code>R.id.decode_failed</code>到<code>CaptureActivityHandler</code>中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (message.what) &#123;</span><br><span class="line"></span><br><span class="line">    	...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> R.id.decode_failed:</span><br><span class="line">            <span class="comment">// We're decoding as fast as possible, so when one decode fails, start another.</span></span><br><span class="line">            state = State.PREVIEW;</span><br><span class="line">            cameraManager.requestPreviewFrame(decodeThread.getHandler(), R.id.decode);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，解析失败时，重新调用<code>requestPreviewFrame</code>获取下一帧预览照片，再拿去解析，知道返回正确结果或者手动退出。</p>
<p>整个过程的时序图如下：</p>
<p><img src="https://blog-1252889355.cos.ap-shanghai.myqcloud.com/zxing%E6%97%B6%E5%BA%8F%E5%9B%BE.png" alt=""></p>

            </div>
        <div class="col-md-1">
        </div>
    </div>







</body>
</html>